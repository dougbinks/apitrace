#!/usr/bin/env python

# This script processes a profile generated by apitrace and outputs a summary of the values for each type of call
# Output in csv format: 
#	Call Type, Mean duration per frame (ms), Mean number of calls per frame, Mean duration per call (ms)

from os import listdir
import sys
import argparse

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# CONSTANTS
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# input file keywords and headers
FRAME_END = 'frame_end'
HEADER_SYMBOL = '#'
HEADER_CALL_TYPE = 'name'
HEADER_CPU_DURA = 'cpu_dura'
HEADER_GPU_DURA = 'gpu_dura'
HEADER_PIXELS = 'pixels'

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# MAIN
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Get parameters ###

# Command-line arguments
parser = argparse.ArgumentParser()
parser.add_argument( 'value', choices=[ 'pcpu', 'pgpu', 'ppd'], help='Generate profile for CPU (pcpu), GPU (pgpu) or Pixel data (ppd).' )
parser.add_argument('--fs', type=int, default=-1, help='Frame Start: number of frame to start at (defaults to first).')
parser.add_argument('--fe', type=int, default=-1, help='Frame End: number of frame to end at (defaults to last).')
parser.add_argument( 'file', help='Input file (e.g. "example_file.profile").' )
args = parser.parse_args()

# profile to generate
if args.value == 'pcpu':
	header_value = HEADER_CPU_DURA
elif args.value == 'pgpu':
	header_value = HEADER_GPU_DURA
if args.value == 'ppd':
	header_value = HEADER_PIXELS

# count total number of frames in file
total_frames = 0
with open( args.file, 'r' ) as f:
	for str_line in f:
		if FRAME_END in str_line:
			total_frames += 1

# get start frame
if ( args.fs < 0 ) or ( args.fs >= args.fe ) or ( args.fs >= total_frames ):
	start_frame = 0
	# feedback to user
	if (args.fs >= args.fe) and (args.fs < total_frames):
		sys.stderr.write( 'Warning: Frame Start defaulting to first frame (' + str( start_frame ) + ').\n' +  
								'\t reason: Frame Start is greater than or equal to Frame End \n' +
								'\t\t (--fs = ' + str( args.fs ) + ') >= (--fe = ' + str( args.fe ) + ')\n' )
	if args.fs >= total_frames:
		sys.stderr.write( 'Warning: Frame Start defaulting to first frame (' + str( start_frame ) + ').\n' +
								'\t reason: Frame Start is greater than or equal to last frame \n' +
								'\t\t (--fs = ' + str( args.fs ) + ') >= ( last frame = ' + str( total_frames ) + ')\n' )
else:
	start_frame = args.fs

# get end frame and calculate number of frames to process
if ( args.fe < 0 ) or ( args.fe > total_frames ):
	num_frames = total_frames - start_frame
	last_frame = total_frames
	# feedback to user
	if args.fe > total_frames:
		sys.stderr.write( 'Warning: Frame End defaulting to last frame (' + str( total_frames ) + '). \n' +
								'\t reason: Frame End is greater than last frame: \n' +
								'\t\t (--fe = ' + str( args.fe ) + ') > ( last frame = ' + str( total_frames ) + ')\n' )
else:
	num_frames = args.fe - start_frame
	last_frame = args.fe

### Retrieve data and perform calculations ###

# dictionaries
sum_duras = {}
num_calls = {}
# pc = per call, pf = per frame
mean_duras_pf = {}
mean_calls_pf = {} 
mean_duras_pc = {}

frame_counter = 0
index_value, index_call_type = 0, 0

# read file line by line and distribute the values into dictionaries
with open( args.file, 'r' ) as f:
	for str_line in f:
		line = str_line.split( )

		# get the column indexes
		if ( frame_counter < 1 ) and (line[0] == HEADER_SYMBOL) : 
			del line[0] #remove the header symbol
			index_call_type = line.index( HEADER_CALL_TYPE )
			index_value = line.index( header_value )

		# count frames
		elif FRAME_END in line:
			frame_counter += 1

		# get data
		elif ( frame_counter >= start_frame ) and ( frame_counter < last_frame ):
			value = float(line[ index_value ])
			if value < 0.0:
				value = 0.0

			call_type = line[ index_call_type ]
			if call_type not in sum_duras:
				sum_duras[ call_type ] = value
				num_calls[ call_type ] = 1
			else:
				sum_duras[ call_type ] += value
				num_calls[ call_type ] += 1

for i in sum_duras:
	mean_duras_pf[i] = sum_duras[i] / num_frames

for i in num_calls:
	mean_calls_pf[i] = float(num_calls[i]) / num_frames

for i in sum_duras:
	mean_duras_pc[i] = sum_duras[i] / num_calls[i]

# assemble the results into a single list, convert, sum and sort
results = []
total_mean_duras_pf, total_mean_calls_pf, total_mean_duras_pc = 0, 0, 0

conv_factor = 1000000 #convert ns to ms
if header_value == HEADER_PIXELS:
	conv_factor = 1

calls = sum_duras.keys()
for i in calls:
	results.append([ i, mean_duras_pf[ i ]/ conv_factor, mean_calls_pf[ i ], mean_duras_pc[ i ]/ conv_factor])
	total_mean_duras_pf += mean_duras_pf[ i ]/ conv_factor
	total_mean_calls_pf += mean_calls_pf[ i ]
	total_mean_duras_pc += mean_duras_pc[ i ]/ conv_factor

results.sort(key = lambda x: x[1], reverse=True)

### Output values in csv format ###

output = ""
isFirstLine = True
for i in results:
	if isFirstLine:
		output = "Call Type,Mean duration per frame (ms),Mean number of calls per frame,Mean duration per call (ms)\n"
		output += "TOTAL," + str( total_mean_duras_pf ) + "," + str( total_mean_calls_pf ) + "," + str( total_mean_duras_pc ) + "\n"
		isFirstLine = False
	isFirstItem = True
	for j in i:
		if isFirstItem:
			output += str(j)
			isFirstItem = False
		else:
			output += ',' + str(j)
	output += '\n'

print output
